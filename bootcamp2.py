# -*- coding: utf-8 -*-
"""Bootcamp2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1glERovqerue5vsUpNUMshWBny1oWB5Lc

#poo
"""

class Coche():
  largochasis =250
  anchochasis =420
  ruedas =4
  enmarcha = False

  def arrancar (self):
    self.enmarcha = True

  def estado (self):
    if (self.enmarcha):
      return "el coche esta en marcha"

    else:
      return "El coche esta parado"

micoche = Coche()
print("El largo del coche es:", micoche.largochasis)
print("El ancho del coche es:", micoche.anchochasis)
print("El coche tiene", micoche.ruedas, "ruedas")


micoche.arrancar()

print(micoche.estado())

"""#Numpy"""

import numpy as np
A = np.array([1,2,3])
print('1D array: ')
print(A)
print()

B = np.array([(1,2,3), (4,5,6)])
print('2D array')
print(B)
print()
print("_______________________________________________________________________")

import sys
S = range (1000)
print('Resultado lista de python: ')
print(sys.getsizeof(5) * len(S))
print()
D = np.arange(1000)
print('Resultado Numpy array:')
print(D.size*D.itemsize)
print("_______________________________________________________________________")

import time
size = 1000000
L1 = range (size)
L2 = range (size)
A1 = np.arange (size)
A2 = np.arange (size)

start = time.time()
resut = [(x,y)for x,y in zip (L1,L2)]
print('Resultado lista de python: ')
print((time.time()-start)*1000)
start=time.time()
print()
result = A1 + A2
print( 'resultado numpy array')
print((time.time() - start)*1000)

"""#Pandas"""

import pandas as pd  #Serie de pandas
datos = [3,2,0,1]
s = pd.Series(datos)
print(s)
print("_______________________________________________________________________")

datos2 = [[1,2,3,4],[5,6,7,8],[9,0,1,2]] #Data frame = Estructuras de datos de dos o mas dimensiones
df = pd.DataFrame(datos2)
print(df)
print("_______________________________________________________________________")

#Dataframe = pd.read_csv('train.csv') #Cargar datos en DataFrames
                                       #Los archivos csv son los mas comunes que se utilizan para cargar

print("_______________________________________________________________________")
#Forma de los datos
datos3 = [[1,2,3,4],[5,6,7,8]] # Con shape podemos conecer las dimensiones que tiene el dataframe y nos dice que tiene 2 filas y 4 columnas
df2 = pd.DataFrame(datos3)
df2.shape

print("_______________________________________________________________________")
#Altura de los datos
datos4 = [[1,2,3,4],[5,6,7,8],[4,5,3,3]] #Nos devolvera el valor de 3 porque tenemos 3 conjuntos
df3 = pd.DataFrame(datos4)
len(df3.index)

print("_______________________________________________________________________")
datos5 = [[3,4,5,6,7], [4,5,6,7,8], [5,6,7,8,9]]
df4 = pd.DataFrame(datos5) #Esto nos muestra estadisticas de resumenes para columnas numericas
df4.describe()

datos6 = [[ 3 , 4 , 5 , 6 , 7] , [ 4 , 5 , 6 , 7 , 8]] #Conocer todas las medias de las columnas usando mean
df5 = pd.DataFrame(datos6)
df5.mean()

datos6 = [[ 3 , 4 , 5 , 6 , 7] , [ 4 , 5 , 6 , 7 , 8]] #Conocer la correlacion entre las columnas en un dataframe usando corr
df5 = pd.DataFrame(datos6)
df5.corr()

datos6 = [[ 9 , 2 , 5 , 6 , 7] , [ 4 , 1 , 6 , 7 , 8]] #Para conocer los numeros de valores no nulos en cada columna
df5 = pd.DataFrame(datos6)
df5.count()

datos6 = [[ 9 , 2 , 5 , 6 , 7] , [ 4 , 1 , 6 , 7 , 8]] #Para conocer la mediana de cada columna
df5 = pd.DataFrame(datos6)
df5.median()

datos6 = [[ 9 , 2 , 5 , 6 , 7] , [ 4 , 1 , 6 , 7 , 8]] #Para conocer la desviacion estandar
df5 = pd.DataFrame(datos6)
df5.std()

datos1 = [[ 9 , 2 , 5 , 6] , [ 4 , 1 , 6 , 7]] #Para seleccionar un dato que se desee, puedes seleccionar una columna
df1 = pd.DataFrame(datos6)
df1[1]

datos1 = [[ 9 , 2 , 5 , 6] , [ 4 , 1 , 6 , 7]] #Para seleccionar varias columnas del DataFrame
df1 = pd.DataFrame(datos6)
df1[[0,1]]

datos1 = [[ 9 , 2 , 5 , 6] , [ 4 , 1 , 6 , 7]] #Para seleccionar un valor utilizando la posicion del mismo tomando en cuenta su fila y columna
df1 = pd.DataFrame(datos6)
df1.iloc[1][3]

datos1 = [[ 9 , 2 , 5 , 6] , [ 4 , 1 , 6 , 7]] #Pudes usar los indices del DataFrame para seleccionar los datos
df1 = pd.DataFrame(datos6)
df1.loc[0]

"""#Conceptos basicos de AI
##Machine learning
Rama de inteligencia artificial generando algoritmos con la capacidad de aprender

_**Aprendizaje supervisado :**_ Dando preguntas y respuestas, usando iris.

_Clasificacion:_  Clasifica los datos en petalos y...

_Regresion:_  Se espera un numero

_**Aprendizaje no supervizado:**_ Se dan las caracteristicas y no etiquetas

**Fases de desarrollo**

Entrenamiento

Prueba

#Clasificacion KNN usando sklearn
"""

import numpy as np  #Para usar arreglos
import sklearn      #Para el algoritmo clasificador
from sklearn.datasets import load_iris  #Para traeer el set de datos de las flores de iris
from sklearn.model_selection import train_test_split  #Para dividir nuestra data en set de entrenamiento y set de testing

iris=load_iris() #Se trae todo el set de datos

type(iris) #Vendra en "Bunch" que es una especie de diccionario

iris.keys() #Las lleaves de nuestro set de datos

iris['data'] #Arreglo matriz de 4 dimensiones, cada renglon es una flor cada columna es una medicion

iris ['target_names'] #Los nombres de las clasificaciones

iris ['target'] # Las etiquetas correspondientes a cada uno de los renglones de nuestra data

iris ['feature_names'] #Los nombres de cada una de las mediciones de la adata

x_train, x_test, y_train, y_test = train_test_split (iris['data'], iris['target']) #Separar nuestra data en set de entrenamiento y de testing

x_train.shape #X para entrenar con sus 112 flores y 4 mediciones

y_train.shape #Etiquetas correspondientes a cada elemento de "x"

from sklearn.neighbors import KNeighborsClassifier #Importar kvecinos cercanos

knn = KNeighborsClassifier (n_neighbors = 10) #Le diremos que considere a los 7 vecinos mas cercanos

knn.fit (x_train, y_train) #La funcion fit sirve para entrenar, los parametros que recibe son "x" y "y" train

knn.score(x_test, y_test) #Sirve para visualizar que tambien aprendio el algoritmo, si cambiamos los vecinos cambia el porcentaje de prediccion

knn.predict([[1.3,2.4,3.1,4.3]]) #Nos dice a que clasificacion pertenence las mediciones

iris.target_names #Volvemos a escribir target_names para ver adonde pertenece

"""#Regresion lineal"""

from sklearn.neighbors import KNeighborsRegressor
from sklearn.datasets import load_boston
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression, Ridge

boston = load_boston()

boston.keys()

boston.data #Se logra visializar lo que almacena cada keys con: "data", "target", "data.shape", "Target.shape"

x_ent, x_test, y_ent, y_test = train_test_split( boston.data, boston.target) #Para el entrenamiento

x_ent.shape #Se utilizaran 379 para entrenar

x_test.shape #para hacer testin se usaran 127

y_test.shape #En "y" solo obendremos 1 vector

knn = KNeighborsRegressor(n_neighbors=3)

knn.fit(x_ent, y_ent) #Entrenamiento

knn.score(x_test, y_test) #Evalua que tan bien aprendio el algoritmo

del knn #Borramos knn para que no consuma epacio dentro del programa

rl=LinearRegression()

rl.fit(x_ent, y_ent)

rl.score(x_test, y_test)

del rl

ridge = Ridge(alpha = .2)

ridge.fit(x_ent, y_ent)

ridge.score(x_test, y_test)
